###############################################################################
##
##    Typemap for Memcached::libmemcached objects
##
##    Copyright (c) 2007 Tim Bunce
##    All rights reserved.
##
##    This typemap is designed specifically to make it easier to handle
##    Perl-style blessed objects in XS.  In particular, it takes care of
##    blessing the object into the correct class (even for derived classes).
##   
###############################################################################
## vi:et:sw=4 ts=4

TYPEMAP

# --- simple types ---
Memcached__libmemcached__return         T_RETURN
Memcached__libmemcached__behavior       T_IV

# XXX need to at least document this as an issue
# Could also check at build time if this perl has 64bit ints and use UV if so
uint64_t                                T_NV

# --- complex types ---
# XXX memory management may be reworked to store structure in scalars
Memcached__libmemcached                 T_PTROBJ_RVIV


INPUT
T_RETURN
        $var = ($type)SvIV($arg)

OUTPUT
T_RETURN
        /* setup return value as a dualvar with int err code and string error message */
        (void)SvUPGRADE($arg, SVt_PVNV);
        sv_setpv($arg, memcached_strerror(NULL, $var));
        SvIVX($arg) = $var;
        SvIOK_on($arg);
        if (TRACE_MEMCACHED(ptr))
            warn(\"\t<= %s return %d %s\", \"${func_name}\", $var, SvPV_nolen($arg));


INPUT
T_PTROBJ_RVIV
        if (!SvOK($arg)) {  /* undef         */
            $var = NULL;    /* treat as null */
        }
        else if (sv_derived_from($arg, \"${(my $ntt=$ntype)=~s/__/::/g;\$ntt}\")) {
            if (SvROK($arg) && SvOK(SvRV($arg))) {
                IV tmp = SvIV((SV*)SvRV($arg));
                $var = INT2PTR($type, tmp);
            }
            else { /* already freed */
                $var = NULL;
            }
        }
        else
            croak(\"$var is not of type ${(my $ntt=$ntype)=~s/__/::/g;\$ntt}\");
        if (TRACE_MEMCACHED(ptr))
            warn(\"\t=> %s(%s %s = 0x%p)\", \"${func_name}\", \"${ntype}\", \"${var}\", (void*)$var);

OUTPUT
T_PTROBJ_RVIV
        if (!$var)          /* if null */
            SvOK_off($arg); /* then return as undef instead of reaf to undef */
        else
            sv_setref_pv($arg, \"${(my $ntt=$ntype)=~s/__/::/g;\$ntt}\", $var);
        if (TRACE_MEMCACHED(ptr))
            warn(\"\t<= %s(%s %s = %p)\", \"${func_name}\", \"${ntype}\", \"${var}\", (void*)$var);

