General:

memcached_get whith no memcached servers running returns 'not found' - is that appropriate?
rename perl-only functions to not have memcached_ prefix?
Align with Cache:: API
Need memcached_mget_by_key_into_hashref?
Add stats api
Document all typedef actions on input and output

Resolve mapping of error codes to booleans
(see parse_*_reply in http://search.cpan.org/src/KROKI/Cache-Memcached-Fast-0.07/src/client.c)

Write a pod that lists all the enum types and their constants
so people can see which tag to use to import a constant.

Structure:
    Aim to be at least thread-safe and ideally thread-hot.
    Add hold PrintError & RaiseError flags
    Add cas support - if sizeof(uint64_t) <= sizeof(UV) then use UV else use a newSV(sizeof(uint64_t))
    and store the uint64_t as a binary string.
    Resolve other uint64_t issues, esp increment/decrement

Tests:
    Add test coverage target
    test errno errstr

CPAN:
    Find out how to get more info into a cpan-testers NA report.

Compatibility:
    Use flags field in a way compatible with Cache::Memcached?
        use constant F_STORABLE => 1;
        use constant F_COMPRESS => 2;
       +use constant F_UTF8     => 4; <= new patch from sugi@nemui.org
    We should certainly support UTF8 in some way and using the same flag bit is sane
    (will reduce migration problems).
    Should we support automatic storable/compress or leave those to higher level code?
    Could support generic get & set key and get & set value callback hooks.
    Like BerkeleyDB filters: http://search.cpan.org/~pmqs/BerkeleyDB/BerkeleyDB.pod#DBM_Filters
    Write Cache::Memcached* emulations and run their test suites.

Random thoughts...

    For *_by_key functions, if $master_key is undef then use some per-$memc mechanism,
    such as a pre-stored scalar, or a callback, to get the value.
